var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import { Component, createElement, cloneElement, isValidElement, } from 'react';
import * as PropTypes from 'prop-types';
import { Transition, ResolveContext, applyPairs, } from '@uirouter/core';
import { UIRouterInstanceUndefinedError } from './UIRouter';
/** @internalapi */
var id = 0;
export var TransitionPropCollisionError = new Error('`transition` cannot be used as resolve token. ' +
    'Please rename your resolve to avoid conflicts with the router transition.');
var UIView = /** @class */ (function (_super) {
    __extends(UIView, _super);
    function UIView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            loaded: false,
            component: 'div',
            props: {},
        };
        return _this;
    }
    UIView.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, render = _a.render;
        var _b = this.state, component = _b.component, props = _b.props, loaded = _b.loaded;
        // register reference of child component
        // register new hook right after component has been rendered
        var stateName = this.uiViewAddress &&
            this.uiViewAddress.context &&
            this.uiViewAddress.context.name;
        // only class components can implement the
        // uiCanExit hook and ref doesn't work on
        // stateless function components
        if (typeof component !== 'string' && !!component.prototype.render) {
            props.ref = function (c) {
                _this.componentInstance = c;
                _this.registerUiCanExitHook(stateName);
            };
        }
        // attach any style or className to the rendered component
        // specified on the UIView itself
        var _c = this.props, className = _c.className, style = _c.style;
        var styleProps = { className: className, style: style };
        var childProps = __assign({}, props, styleProps);
        var child = !loaded && isValidElement(children)
            ? cloneElement(children, childProps)
            : createElement(component, childProps);
        // if a render function is passed use that,
        // otherwise render the component normally
        return typeof render !== 'undefined' && loaded
            ? render(component, childProps)
            : child;
    };
    UIView.prototype.getChildContext = function () {
        return {
            parentUIViewAddress: this.uiViewAddress,
        };
    };
    UIView.prototype.componentWillMount = function () {
        var router = this.context['router'];
        if (typeof router === 'undefined') {
            throw UIRouterInstanceUndefinedError;
        }
        // Check the context for the parent UIView's fqn and State
        var parent = this.context['parentUIViewAddress'];
        // Not found in context, this is a root UIView
        parent = parent || { fqn: '', context: router.stateRegistry.root() };
        var name = this.props.name || '$default';
        this.uiViewData = {
            $type: 'react',
            id: ++id,
            name: name,
            fqn: parent.fqn ? parent.fqn + '.' + name : name,
            creationContext: parent.context,
            configUpdated: this.viewConfigUpdated.bind(this),
            config: undefined,
        };
        this.uiViewAddress = { fqn: this.uiViewData.fqn, context: undefined };
        this.deregister = router.viewService.registerUIView(this.uiViewData);
        this.setState({ id: this.uiViewData.id });
    };
    UIView.prototype.componentWillUnmount = function () {
        this.deregister();
    };
    /**
     * View config updated callback
     *
     * This is called by UI-Router during ViewService.sync().
     * The `newConfig` parameter will contain view configuration (component, etc) when a
     * state is activated and one of its views targets this `UIView`.
     */
    UIView.prototype.viewConfigUpdated = function (newConfig) {
        if (newConfig === this.uiViewData.config) {
            return;
        }
        var trans;
        var resolves = {};
        if (newConfig) {
            var viewContext = newConfig.viewDecl && newConfig.viewDecl.$context;
            this.uiViewAddress = { fqn: this.uiViewAddress.fqn, context: viewContext };
            var resolveContext = new ResolveContext(newConfig.path);
            var injector_1 = resolveContext.injector();
            var stringTokens = resolveContext.getTokens()
                .filter(function (x) { return typeof x === 'string'; });
            if (stringTokens.indexOf('transition') !== -1) {
                throw TransitionPropCollisionError;
            }
            trans = injector_1.get(Transition);
            resolves = stringTokens
                .map(function (token) { return [token, injector_1.get(token)]; })
                .reduce(applyPairs, {});
        }
        this.uiViewData.config = newConfig;
        var props = __assign({}, resolves, { transition: trans });
        var newComponent = newConfig && newConfig.viewDecl && newConfig.viewDecl.component;
        this.setState({
            component: newComponent || 'div',
            props: newComponent ? props : {},
            loaded: !!newComponent,
        });
    };
    UIView.prototype.registerUiCanExitHook = function (stateName) {
        typeof this.removeHook === 'function' && this.removeHook();
        var criteria = { exiting: stateName };
        var callback = this.componentInstance &&
            typeof this.componentInstance.uiCanExit === 'function' &&
            this.componentInstance.uiCanExit;
        if (stateName && callback) {
            var transitions = this.context['router'].transitionService;
            this.removeHook = transitions.onBefore(criteria, callback, {});
        }
    };
    UIView.propTypes = {
        name: PropTypes.string,
        className: PropTypes.string,
        style: PropTypes.object,
        render: PropTypes.func,
    };
    UIView.childContextTypes = {
        parentUIViewAddress: PropTypes.object,
    };
    UIView.contextTypes = {
        router: PropTypes.object,
        parentUIViewAddress: PropTypes.object,
    };
    return UIView;
}(Component));
export { UIView };
//# sourceMappingURL=UIView.js.map